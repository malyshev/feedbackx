import { Column, CreateDateColumn, Entity, Index, PrimaryGeneratedColumn } from 'typeorm';

import { Expose } from 'class-transformer';

/**
 * Feedback Entity
 *
 * Represents a single immutable feedback submission - an append-only event record.
 * Each feedback belongs to exactly one realm and contains a score validated against the realm's scale configuration.
 *
 * Design Philosophy:
 * - Anonymous by default (no user tracking, no PII)
 * - Append-only (immutable, no updates/deletes)
 * - Realm-scoped (belongs to one realm via denormalized references)
 * - No semantic validation (validation happens at API layer, not schema)
 * - Event storage (not relational integrity - no FK constraints)
 * - Future-proof (flexible schema via JSONB for score, metadata)
 * - Boring in the best sense (simple, predictable, maintainable)
 *
 * Usage:
 * - Written often (high write volume from feedback submissions)
 * - Read rarely (primarily for analytics, exports, reporting)
 * - Realm configuration (scale, metadata schema) defines validation rules
 * - Feedback submissions validated against realm.scale and realm.metadata before insert
 *
 * Example scenarios:
 * - Product feedback: score 4 (numeric 1-5), comment "Great UI!", metadata { version: "2.0" }
 * - Support ticket: score "positive" (enum), selectedOptions ["response-time", "helpfulness"]
 * - Feature request: score 8 (numeric 0-10), comment "Would love dark mode"
 *
 * @Entity('feedbacks')
 */
@Entity('feedbacks')
@Index(['realmId', 'createdAt'])
@Index(['realmKey', 'createdAt'])
@Index(['realmKey'])
export class FeedbackEntity {
    /**
     * Feedback unique identifier (UUID)
     * Auto-generated UUID primary key - used internally for database queries and references
     * Default: auto-generated by PostgreSQL (uuid type)
     * Format: standard UUID v4 (e.g., '550e8400-e29b-41d4-a716-446655440000')
     * Example: Use in database queries and internal references
     */
    @PrimaryGeneratedColumn('uuid')
    @Expose()
    public readonly id!: string;

    /**
     * Realm internal ID (UUID) - denormalized reference
     * Denormalized reference ‚Äî no FK constraint on purpose.
     *
     * Why denormalized:
     * - Avoids cascading deletes surprises (feedback survives realm deletion)
     * - Allows realm soft-delete without data loss
     * - Simplifies ingestion pipelines (no FK lookup required)
     * - Enables analytics without joins (faster queries)
     *
     * Why stored when realmKey exists:
     * - realmKey is human-readable but can change (though discouraged)
     * - realmId is stable UUID reference for internal queries
     * - Both stored for flexibility (can query by either)
     * - realmKey stored for analytics/export (human-readable)
     * - realmId stored for efficient indexing and internal references
     *
     * Default: required (must be provided when creating feedback)
     * Format: standard UUID v4 matching RealmEntity.id
     * Example: '550e8400-e29b-41d4-a716-446655440000'
     */
    @Column({ type: 'uuid', name: 'realm_id', nullable: false })
    public realmId!: string;

    /**
     * Public realm key (slug) - denormalized and indexed
     * Stored redundantly for analytics and query performance.
     *
     * Why stored redundantly:
     * - Easier analytics without joins (query by realmKey directly)
     * - Easier partitioning by realm_key later (if needed for scale)
     * - Exporting data without lookup tables (self-contained records)
     * - Storage is cheap, joins are expensive (denormalization trade-off)
     *
     * Default: required (must be provided when creating feedback)
     * Format: URL-safe string matching RealmEntity.key
     * Constraints:
     *   - Maximum length: 64 characters (matches RealmEntity.key)
     *   - Should match the realm.key from RealmEntity (validated at API layer)
     * Examples:
     *   - 'product-a'
     *   - 'mobile-app-staging'
     *   - 'customer-support-v2'
     */
    @Column({ length: 64, name: 'realm_key', nullable: false })
    public realmKey!: string;

    /**
     * Score value - validated against realm.scale configuration
     * Type intentionally loose to support multiple scale types.
     *
     * Type flexibility:
     * - number for numeric scales (e.g., 1-5, 0-10)
     * - string for enum scales (e.g., "positive", "negative", "neutral")
     * - Future: could support emoji scales (e.g., "üôÇ", "üòê", "üôÅ")
     *
     * Validation:
     * - Happens at API layer (before insert)
     * - Validated against realm.scale configuration:
     *   - Numeric scales: value must be within min-max range
     *   - Enum scales: value must be in values array
     * - Schema stores as JSONB (flexible, no strict type enforcement)
     *
     * Default: required (must be provided when creating feedback)
     * Storage: JSONB column (PostgreSQL flexible JSON storage)
     * Examples:
     *   - Numeric: 7 (for scale min:0, max:10)
     *   - Enum: "positive" (for scale values: ["negative", "neutral", "positive"])
     */
    @Column({ type: 'jsonb', nullable: false })
    public score!: number | string;

    /**
     * Optional selected options (checkbox-style feedback)
     * Array of option identifiers selected by the user.
     *
     * Use case:
     * - Multi-select checkboxes (e.g., "What did you like? [price] [support] [speed]")
     * - Tags/categories selected by user
     * - Feature flags or attributes relevant to feedback
     *
     * Validation:
     * - Happens at API layer (if realm defines allowed options)
     * - No schema-level validation (flexible, no strict constraints)
     * - Array can be empty (user selects no options)
     *
     * Default: optional (can be null)
     * Storage: JSONB column (PostgreSQL array storage)
     * Examples:
     *   - ["price", "support", "speed"]
     *   - ["ui", "performance", "features"]
     *   - ["mobile-app", "dark-mode"]
     */
    @Column({ type: 'jsonb', nullable: true, name: 'selected_options' })
    public selectedOptions?: string[];

    /**
     * Optional free-form text feedback comment
     * Unstructured text input from the user.
     *
     * Characteristics:
     * - No semantic validation (no NLP, no sentiment analysis)
     * - No opinion extraction (just stores text as-is)
     * - Not indexed (full-text search can be added later if needed)
     * - Not required (user can submit score-only feedback)
     *
     * Use case:
     * - User provides additional context beyond score
     * - Qualitative feedback to complement quantitative score
     * - Free-form suggestions or complaints
     *
     * Default: optional (can be null)
     * Storage: TEXT column (PostgreSQL text type, unlimited length)
     * Examples:
     *   - "Great UI, but loading times are slow"
     *   - "Love the new dark mode!"
     *   - "Could use better documentation"
     */
    @Column({ type: 'text', nullable: true })
    public comment?: string;

    /**
     * Optional metadata payload - validated against realm.metadata schema
     * Additional structured data fields specific to the realm.
     *
     * Validation:
     * - Shape validated against realm.metadata schema (at API layer)
     * - Semantics ignored (API validates structure, not business logic)
     * - No schema-level validation (flexible JSONB storage)
     *
     * Use case:
     * - Capture context-specific data (user ID, app version, feature flags, etc.)
     * - Enable filtering and analytics on custom fields
     * - Different realms can have different metadata schemas
     *
     * Default: optional (can be null)
     * Storage: JSONB column (PostgreSQL flexible JSON storage)
     * Examples:
     *   - { userId: "user-123", version: "2.0.1" }
     *   - { sessionId: "sess-456", platform: "ios", language: "en" }
     *   - { featureFlags: ["dark-mode", "beta"], environment: "production" }
     */
    @Column({ type: 'jsonb', nullable: true })
    public metadata?: Record<string, unknown>;

    /**
     * Feedback submission timestamp - automatically set when feedback is created
     * Auto-managed by TypeORM - set automatically on INSERT operations
     * Default: current timestamp when feedback is created (auto-generated by PostgreSQL)
     * Format: ISO 8601 timestamp (e.g., '2026-01-10T10:30:00.000Z')
     *
     * Characteristics:
     * - Immutable (never changes after creation - append-only design)
     * - Indexed (part of composite indexes for time-series queries)
     * - Used for analytics, sorting, filtering by date ranges
     *
     * Usage:
     * - Used for time-series queries (feedback over time per realm)
     * - Used for analytics and reporting (grouping by date ranges)
     * - Used for sorting feedback submissions (newest first, oldest first)
     * - Never modified after creation (immutable by design)
     * Example: Use in analytics queries to group feedback by date, or in admin UI to show submission time
     */
    @CreateDateColumn({ name: 'created_at' })
    @Expose()
    public readonly createdAt!: Date;
}
