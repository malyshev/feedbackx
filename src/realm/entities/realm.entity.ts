import { Column, CreateDateColumn, Entity, Index, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';

import { Expose } from 'class-transformer';

/**
 * Realm Entity
 *
 * Represents a feedback collection realm - a namespace/context for organizing feedback.
 * Realms allow multiple applications or services to collect feedback independently within
 * the same FeedbackX instance, each with its own configuration, authentication, and scoring scale.
 *
 * Usage:
 * - Create a realm for each application, service, or feedback context
 * - Each realm has its own API key for client authentication
 * - Clients submit feedback to a realm using its unique key (slug) in the URL: POST /realms/:key/feedbacks
 * - Realm configuration (scale, metadata schema) defines how feedback is structured and validated
 *
 * Example scenarios:
 * - Multiple products: one realm per product (e.g., 'product-a', 'product-b')
 * - Environment separation: one realm per environment (e.g., 'staging', 'production')
 * - Feature-specific feedback: one realm per feature (e.g., 'mobile-app', 'web-app')
 *
 * @Entity('realms')
 */
@Entity('realms')
export class RealmEntity {
    /**
     * Realm unique identifier (UUID)
     * Auto-generated UUID primary key - used internally for database relationships
     * Default: auto-generated by PostgreSQL (uuid type)
     * Not exposed in API responses by default (use key instead for public access)
     * Format: standard UUID v4 (e.g., '550e8400-e29b-41d4-a716-446655440000')
     * Example: Use in database queries and internal references
     */
    @PrimaryGeneratedColumn('uuid')
    @Expose()
    public readonly id!: string;

    /**
     * Realm name - human-readable identifier for administration and UI
     * Used for display purposes in admin interfaces, logs, and management tools
     * Not used for API routing - use key property instead for URL paths
     * Default: required (must be provided when creating a realm)
     * Constraints:
     *   - Maximum length: 63 characters (DNS label limit for portability)
     *   - Must be unique across all realms
     *   - Case-sensitive (can have 'Product-A' and 'product-a' as different realms)
     * Examples:
     *   - 'Production Feedback'
     *   - 'Mobile App'
     *   - 'Customer Support'
     *   - 'Feature Request - Dark Mode'
     */
    @Index({ unique: true })
    @Column('varchar', {
        length: 63,
        nullable: false,
    })
    @Expose()
    public name!: string;

    /**
     * Realm key (slug) - public identifier used for API routing and client access
     * Used in URL paths for feedback submission: POST /realms/:key/feedbacks
     * Provides portability - clients can use a stable key instead of internal UUID
     * Required for all realms - must be provided when creating a realm
     * Default: required (must be provided when creating a realm)
     * Constraints:
     *   - Maximum length: 64 characters (reasonable limit for URLs and identifiers)
     *   - Must be unique across all realms
     *   - Should be URL-safe (lowercase, alphanumeric, hyphens/underscores recommended)
     *   - Once set, changing it requires updating all client integrations
     * Examples:
     *   - 'product-a' → POST /realms/product-a/feedbacks
     *   - 'mobile-app-staging' → POST /realms/mobile-app-staging/feedbacks
     *   - 'customer-support-v2' → POST /realms/customer-support-v2/feedbacks
     * Use cases:
     *   - Human-readable URLs for easier client integration
     *   - Stable identifier that doesn't change if database is migrated
     *   - Self-documenting API endpoints (clients understand context from URL)
     */
    @Index({ unique: true })
    @Column({ length: 64, nullable: false })
    public key!: string;

    /**
     * Realm description - optional text description for administration
     * Used for documentation and admin UI purposes - helps understand realm purpose
     * Not used in API logic or routing
     * Default: optional (can be null)
     * Constraints:
     *   - Maximum length: 255 characters (reasonable limit for descriptions)
     *   - Can contain any text (newlines, special characters allowed)
     * Examples:
     *   - 'Collects feedback for production mobile app'
     *   - 'Customer support feedback from help desk tickets'
     *   - 'Feature request feedback for dark mode implementation'
     */
    @Column('varchar', {
        length: 255,
        nullable: true,
    })
    @Expose()
    public description?: string;

    /**
     * Realm API key - authentication credential for client applications
     * Required for all feedback submissions to this realm - clients must provide this key
     * Used in Authorization header: Authorization: Bearer <apiKey>
     * Security considerations:
     *   - Should be treated as a secret (like password)
     *   - Must be unique across all realms
     *   - Should be randomly generated (e.g., using crypto.randomBytes or similar)
     *   - Minimum recommended length: 32 characters for security
     *   - Store securely - never commit to version control
     *   - Rotate periodically in production environments
     * Default: required (must be provided when creating a realm)
     * Example generation:
     *   - Node.js: require('crypto').randomBytes(32).toString('hex')
     *   - CLI: openssl rand -hex 32
     * Usage:
     *   - Clients use this key to authenticate requests to POST /realms/:key/feedbacks
     *   - Different realms can have different API keys (enables revocation per realm)
     *   - Key rotation requires updating all clients that use this realm
     */
    @Column({ name: 'api_key' })
    public apiKey!: string;

    /**
     * Feedback scoring scale configuration - defines how numeric/rating feedback is structured
     * Determines the format and constraints for feedback scores submitted to this realm
     * Stored as JSONB for flexible schema and efficient querying in PostgreSQL
     * Default: required (must be provided when creating a realm)
     * Supported types:
     *   - 'numeric': Continuous numeric range (e.g., 0-10, 1-5)
     *   - 'enum': Discrete predefined values (e.g., ['bad', 'ok', 'great'])
     * Numeric scale properties:
     *   - min: Minimum allowed value (number, inclusive)
     *   - max: Maximum allowed value (number, inclusive)
     *   - Example: { type: 'numeric', min: 0, max: 10 } → allows 0, 0.5, 5, 10, etc.
     * Enum scale properties:
     *   - values: Array of allowed string values (must be unique)
     *   - Example: { type: 'enum', values: ['bad', 'ok', 'great'] } → only these three values allowed
     * Validation:
     *   - API validates submitted feedback against this scale configuration
     *   - Numeric: checks if value is within min-max range
     *   - Enum: checks if value is in the values array
     * Examples:
     *   - 5-star rating: { type: 'numeric', min: 1, max: 5 }
     *   - NPS-style (0-10): { type: 'numeric', min: 0, max: 10 }
     *   - Simple feedback: { type: 'enum', values: ['negative', 'neutral', 'positive'] }
     *   - Likert scale: { type: 'enum', values: ['strongly-disagree', 'disagree', 'neutral', 'agree', 'strongly-agree'] }
     */
    @Column({ type: 'jsonb' })
    public scale!: {
        type: 'numeric' | 'enum';
        min?: number;
        max?: number;
        values?: string[];
    };

    /**
     * Optional metadata schema definition - defines additional structured data fields for feedback
     * Allows realm-specific custom fields beyond the core feedback (score, text, checkboxes)
     * Stored as JSONB for flexible schema and efficient storage/querying in PostgreSQL
     * Default: optional (can be null - feedback has no metadata schema)
     * Important: API does NOT enforce semantics - only validates JSON structure/shape
     *   - API validates that metadata matches the schema structure (types, required fields)
     *   - API does NOT validate business logic (e.g., whether email format is valid, date ranges)
     *   - Clients are responsible for enforcing semantic validation (format, business rules)
     * Schema format:
     *   - JSON Schema or similar structure describing allowed fields
     *   - Defines field types, required fields, constraints
     *   - Example: { properties: { userId: { type: 'string' }, version: { type: 'string' } }, required: ['userId'] }
     * Use cases:
     *   - Capture context-specific data (user ID, app version, feature flags, etc.)
     *   - Enable filtering and analytics on custom fields
     *   - Different realms can have different metadata schemas based on their needs
     * Examples:
     *   - App version tracking: { version: 'string', platform: 'string' }
     *   - User context: { userId: 'string', sessionId: 'string' }
     *   - Feature flags: { featureFlags: 'array', environment: 'string' }
     * Storage:
     *   - Stored in realm entity for reference
     *   - Actual metadata values are stored in feedback submissions (not here)
     *   - This is the schema/contract, not the data
     */
    @Column({ type: 'jsonb', nullable: true, name: 'metadata' })
    public metadata?: Record<string, unknown>;

    /**
     * Realm creation timestamp - automatically set when realm is created
     * Auto-managed by TypeORM - set automatically on INSERT operations
     * Default: current timestamp when realm is created (auto-generated by PostgreSQL)
     * Format: ISO 8601 timestamp (e.g., '2026-01-10T10:30:00.000Z')
     * Usage:
     *   - Used for auditing and tracking when realms were created
     *   - Useful for analytics and reporting (e.g., realms created per month)
     *   - Never modified after creation (immutable)
     * Example: Use in admin UI to show realm creation date, or in analytics queries
     */
    @CreateDateColumn({ name: 'created_at' })
    @Expose()
    public readonly createdAt!: Date;

    /**
     * Realm last update timestamp - automatically updated when realm is modified
     * Auto-managed by TypeORM - updated automatically on UPDATE operations
     * Default: current timestamp when realm is created, then updated on each modification
     * Format: ISO 8601 timestamp (e.g., '2026-01-10T10:30:00.000Z')
     * Usage:
     *   - Used for auditing and tracking when realms were last modified
     *   - Useful for cache invalidation (check if realm config changed)
     *   - Automatically updated by TypeORM when any field changes
     * Example: Use to detect stale realm configurations, or in admin UI to show last update time
     */
    @UpdateDateColumn({ name: 'updated_at' })
    @Expose()
    public readonly updatedAt!: Date;
}
